--2--
This video will discuss picking, or selection, using a variety of methods that vary in effieciency and complexity.

--3--
The ability to test the intersection of geometric objects is integral to the features we will be learning and implementing throughout the course.

In this video, we will discuss, picking or selection, which is a way of selecting an object from a scene using a mouse click. This is directly related to Ray tracing since this method involves tracing a ray from the view reference point through the pixel selected by the mouse click to find the first object in the scene that the ray intersects.

Later, we will talk more about ray, tracing and collision detection between objects.

In order to perform collision tests efficiently, we will need to employ bounding volumes. Bounding volumes are simple geometric shapes that enclose more-complex geometric shapes or groups of geometric shapes. We will discuss those in the next video.

--4--
There are variouse established method for performing picking; I'll go over the OpenGL method for the next few slides.  Even though we won't be using this method, it is worth-while to review it. Also, it has been deprecated, so it will no longer work with the open GL core profile.

The method is simple. You define a very small render window, redraw all of the objects and OpenGL will return the list of objects that are within that window, along with their depth values. This method was not graphics hardware accelerated.

--5--
First you register a select buffer. This is the buffer in which the selected objects will be returned. Then you enter the render mode GL_SELECT, and you initialize the names stack.

The GL utility had a pick matrix method that allowed you to pass in the viewport, as well as the X, Y coordinates, and the width and depth around those coordinates that will define your selection window.

As you draw you push and pop names of objects, or names of groupings of objects, that may or may not be returned in the select buffer.

--6--
Here is some sample code of how this would have been done in OpenGL. Note this will not compile using the OpenGL core profile, only on compatibility mode.

--7--
To specify the pick region, after some set up to retained the OpenGL state, you call glePickMatrics with the XY coordinates that will be the center of the selection region, the width and height of the selection region, and the viewport parameters. Remember that the mouse and screen coordinates increase from top to bottom and OpenGL increases from bottom to top.

--8--
An alternative method uses the accelerated GPU hardware as proposed by Haeberli and Hanrahan. This also requires a separate rendering pass, but with no lighting calculations. Each polygon has a separate distinct color, which is used as an identifier. This method can be very efficient in applications where there are many objects to be rendered.

Similar methods have been proposed using a stencil buffer during the main rendering pass. In most systems, the depth buffer and step stencil, buffer share the same memory, so using a stencil buffer implies a loss of precision for the depth values. During rendering the stencil value for each fragment will be a unique identifier for the object.

Since stencil buffers typically only have eight bits, you're limited to 256 unique identifiers, which may not be enough for scenes with many objects

--9--
Perhaps the easiest method if not the fastest, and the one we will be implementing in this course, is to follow a ray starting at the view reference point, or camera position, and in the direction of a point on the view plane, and determine the first object the ray intersects.

We did a little bit with rays in the previous course and will we will use them extensively in this course.

As a review, a ray is defined as an origin point and a direction vector. T is the value along the direction vector from the origin. Positive values of T indicate a point along the ray in front of the origin point in the direction of the vector. Negative values denote a point behind the origin.

--10--
Ray operations are simplified if the direction vector is unit length.

For selection, we are only concerned with intersections in front of the ray. You can do this by iterating over all of the objects in the scene and finding the shortest distance. 

I recommend maintaining a value of the shortest distance, initialized to the maximum float value.  As you iterate over the objects in the scene, you update the current shortest distance value as you intersect objects closer than it.

This is a brute force approach, but it is correct. We will soon be discussing methods of optimizing this. But as I often say, get it right first, then optimize.

This concludes this video.
