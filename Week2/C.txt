--2--
In this video, we will discuss the recursive parts of our retracing algorithm. 

We will discuss recursion at a high-level, and then specifically discuss reflection, refraction, and shadow generation.

--3--
This image, from a class in 2008, was rendered using all of the topics that we will discuss in this video.

--4--
In the previous video, we discussed how rays are constructed from the camera point through the pixels on the view plane. Once we find that initial intersection point, we may spawn additional rays to determine the reflected, or refracted light that also contribute to the color at that point. Also, we spawn a ray from that intersection point to each light source to determine whether or not that point receives light directly from that source, or is obscured by another object in its path. This determines the light contribution at that point including whether or not the point is shadowed.

Shadow rays are simple and end at each light source. However, reflected and refracted rays are meant to intersect objects in the scene. So, for each of those intersections, we need to repeat the process, determining light contribution, including shadows, and possibly spawn additional reflected and refracted rays.

Due to the recursive nature of retracing, it is often implemented as a recursive algorithm.

--5--
This diagram illustrates and example. 

You can see that an initial ray is traced from the eye through the view plane and intersects a partially transparent object. The light on that surface is determined by tracing a ray from that point to the light source. 

Then two additional rays are generated, one is refracted through the object and the other reflected off of the surface. 

For each of these two additional rays, we also need to determine the light contribution at their intersection points, and add their light contributions to the initial intersection point.

--6--
It may help to visualize this process as a tree structure. Each node could be an intersection point and each parent-child relationship, a ray generated from a shadow, reflected or refracted ray. We could then halt the ray-tracing process once the graph reaches a predetermined maximum depth. 

The maximum depth represents the fact that additional rays' contributions will be so insignificant that they can be ignored.

--7--
This slide shows the pseudo code for implementing a recursive ray tracer.

Note that this implements all three types of recursive rays iterating over each light source for the shadow rays, and only spawning a reflective and refractive ray if necessary. It also checks the recursion level to determine max depth.

--8--
Determining a reflected ray should be familiar to you already, as we have done this in our shading models for specular highlights. Make sure that you understand the reflection concepts and mathematics, and go back and review if needed.

--9--
Refraction is new to us, and is somewhat more complicated than reflection, but is quite similar.

You can see that the sphere in the center of this image refracts the light and produces a crystal ball effect on the rest of the scene.

--10--
Refraction is the effect of light passing from one material into another. Light travels at different speeds, depending on the material the light traverses. If the light enters the material head on, or parallel to direction of the normal to the surface that point, no refraction occurs.  However, if the light enters the surface at an angle, the light can slow down or speed up and give the appearance of it bending as it travels.

We calculate this bend, or refraction, using Snells law, which requires the incident angle and the indices of a fraction of the two media.

Consider the case where we look through glass. As light travels between the eye and the glass. The air has a low refractive index and its affect on light is nearly imperceptible.

However, as the light travels through glass, which has a much higher refractive index, the light appears to bend. As the light exits the glass, it  travels nearly along its previous path, giving the effect that the light is slightly offset.

--11--
If we know the incoming direction of the ray and the normal to the surface at the intersection of the ray and the surface, and the index of refraction of the media, we can determine the refracted direction of the ray using the math provided on this slide.

The factor mu is the ratio of the exiting medium over the entering medium. Then the refracted direction is mu times I, the initial direction of the ray, minus mu times I dot N plus cosine phi times the normal vector. Cosine phi is the square root of one minus mu squared times 1 minus I dot N squared.  Both I and N are assumed to be unit length.

This formula is derived by using the relationship of M times sine phi minus cosine phi, where M is a unit vector perpendicular to N in the plane of I and T.

You can follow the rest of the derivation as explained on the slide.

--12--
Since most of the information can be derived using the ray mathematics that we have been using thus far, the only variables left are the indices of refraction. There are many resources on the internet that have the indices of refraction for common materials, but I have listed a few here for convenience.

--13--
If the incident angle of the incoming ray is sufficiently large, then phi exceeds 90Â° and the ray is reflected instead of refracted. This is called total internal reflection.

Theta C is called the critical angle, the angle at which total internal reflection occurs. We can detect this while computing cosine phi. If the value under the square root is less than zero, the value will be imaginary and total internal reflection has occurred. Therefore we would compute a relected ray instead of a refracted ray.

--14--
To handle refractive recursion in ray tracing, we must keep track of the medium and its refractive index through which the ray is passing in order to properly determine mu. 

If we add the constraint that translucent objects cannot enter penetrate, the problem becomes simpler. 

The ray alternates between inside an object and the outside air. Note, when determining the exit ray of a translucent objects, we must reverse the sign of the normals in order to properly compute the exiting refracted ray.

If translucent objects can interpenetrate, the problem becomes a little more complicated, but not impossible. In this case, we keep track of the objects the ray is inside in a list, with the corresponding materials properties. 

--15--
Finally, we will discuss shadows.

--16--
Until now, we have only considered local lighting contribution, which is if a point receives light from a light source. In ray tracing, we can easily determine if there is an object in between the intersection point and the light sources in our scene.

We create a ray, often called a shadow feeler, from the intersection point to each light source, and determine if there is an object in its path.

If there is no object, then we compute the light contribution normally. However, if there is an object in the path, then the intersection point only receives the ambient contribution for that light source.

--17--
A shadow feeler must be generated for each light source in the scene. This increases the computational intensity the more lights we add to the scene. For a standard ray tracer this means that each ray will spawn up to N plus 2 rays. 

The shadow feelers are less expensive than normal rays since they do not spawn additional reflected or refracted rays, and do not need to test for all intersections just if an intersection occurs.


This concludes this video.
