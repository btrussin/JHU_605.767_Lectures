8D: Shadow Volumes

https://www.gamedev.net/reference/articles/article1873.asp [The Theory of Stencil Shadow Volumes]
https://www.nvidia.com/docs/IO/8230/GDC2003_ShadowVolumes.pdf [Shadow Volumes - NVIDIA]
https://www.gamedeveloper.com/business/real-time-shadow-casting-using-shadow-volumes [Real-Time Shadow Casting Using Shadow Volumes]


--2-- File 65
In this video, we discuss shadow volumes.  Like planar projection shadows, this technique is not widely used, and not a good solution overall.  However, we will cover it, partly for legacy purposes, but also becuase the techniques used here are valuable.

--3-- File 66
This image was generated using shadow volumes. As you can see, shadows are accurately projected onto curved surfaces, already making this a better solution than planar projection shadows.

--4-- File 68
The idea for shadow volumes originated in the 1970s. The basic idea is to treat shaded regions of a scene as polygons and take advantage of already-established polygon rendering functions.

A shadow volume is a semi-infinite pyramid whose upper-edge is defined at the silhouette edge of an object in the scene and extends in the direction of the light source origin to the object.

The volumes themselves are not rendered, but do go through a special render pass.

--5-- File 73
Shadow volumes are used in algorithms that are similar to hidden surface removal algorithms. Once shadow volumes are computed, regular objects are rendered and fragments are determined to be either inside any or outside of all shadow volumes in the scene.

The concept is to follow a ray from the view point to the fragment being rendered, and a counter keeps track of the number of volumes it has entered and exited before reaching the fragment.  For this reason, we need to know if the polygon of the shadow volume is front-facing or back-facing, to know if the ray entered or exited the volume.

--6-- File 74
Per pixel, we keep a counter. Each time the ray enters a shadow volume, the counter gets incremented. And as it exits a volume, it is decremented. This counting occurs until the ray reaches the depth currently stored in the depth buffer.  If the count is zero, the fragment occupying the framebuffer is out of shadow and gets full lighting.  If the count is greater than zero, then the fragment is in shadow.

This whole process is done using the stencil buffer and associated logic.

--7-- File 75
This illustration shows a shadow volume cast into the scene by the purple object.  The tan object is partially in shadow. No matter the angle of the viewer, as long as the view reference point is outside of the shadow volume, this algorithm works.

--8-- File 77
This shows the counting logic as it would apply to a view reference point to the left of the volumes. You can see the counter value as a ray moves to the right and enters and exits the volumes.

--9a-- File 78
The entire algorithm is as follows. First, you render the scene normally but with only ambient and emission properties of the objects. This sets the depth value and color for each pixel that will be passed to the display controller.

Next you render the front faces of the shadow volumes. During this phase you increment the stencil value for each pixel, because the depth test will only pass for front facing shadow volumes that are closer to the viewer than the current depth value.  Note that at this time you do not update the depth value, but depth testing is still enabled.

--9b-- File [[REDO]] 0
Then you render the back faces of the shadow volumes. At this phase you decrement the stencil value for each pixel as only the back faces that are closer to the viewer than the current depth value will pass.

Finally, you render the scene again with the diffuse and specular components, but the stencil test only passes when the stencil value for each fragment is zero.

--10-- File [[REDO]] 4
One problem with this algorithm is that it does not work if the view reference point is inside of a shadow volume.

John Carmack, the founder of id Software, the producer of games like Wolfenstein 3D and Doom, and others came up with a simple solution to this problem by reversing the shadow volume rendering phase. Their method is to increment the counter when the back face depth fails, then decrement the counter each time a front face depth passes. If you're curious to know that this works, take the time to work it out on paper.

Another approach to solving this problem is to cap the shadow volumes, so that they're not semi-infinite but closed, and ensure that each volume is closed outside of the view reference point.

--11-- File 85
Generating the shadow volumes can be expensive, and there are more efficient methods than others.

You could create a quadrilateral for every triangle of a shadowing object, but that's highly inefficient.

It would be best if you could use only the silhouette of an object, the edges with respect to the object projected onto the light source.

The text suggests using a geometry shader where for each silhouette triangle, a quadrilateral is created.

You could also pre-define polygons to compute the shadow volumes, but this does not work well for complex mesh objects.

--12-- File 90
There are some algorithmic approaches to creating shadow volumes and I've included some links here if you want to look into this further.

There are multiple cases where the shadow volume technique is quite inefficient, and other cases where it simply does not work. For example, drawing translucent objects with blending does not work with the depth and stencil tests outlined here. For these and other reasons, shadow volumes have largely been abandoned in favor of shadow mapping, which we will discuss next.

This concludes this video
